package com.autoguard.malware_scanner

import android.content.Context
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.io.FileInputStream
import java.security.MessageDigest
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream
import java.io.BufferedInputStream
import java.io.ByteArrayOutputStream

/**
 * Production-grade APK analyzer
 * Extracts APK contents, parses DEX bytecode, computes hashes
 */
class APKAnalyzer(private val context: Context) {
    
    /**
     * Analyze an installed APK file
     * Returns comprehensive analysis including:
     * - File hashes (MD5, SHA1, SHA256)
     * - DEX bytecode hashes
     * - Extracted strings from DEX
     * - API calls detected
     * - Hidden DEX/JAR files in assets
     * - Code obfuscation indicators
     */
    fun analyzeAPK(packageName: String): JSONObject {
        val result = JSONObject()
        
        try {
            val pm = context.packageManager
            val packageInfo = pm.getPackageInfo(packageName, 0)
            val apkPath = packageInfo.applicationInfo?.sourceDir ?: return result.apply {
                put("success", false)
                put("error", "APK path not found")
            }
            
            result.put("packageName", packageName)
            result.put("apkPath", apkPath)
            
            // 1. Compute file hashes
            val hashes = computeAPKHashes(apkPath)
            result.put("hashes", hashes)
            
            // 2. Extract and analyze DEX files
            val dexAnalysis = extractAndAnalyzeDEX(apkPath)
            result.put("dexAnalysis", dexAnalysis)
            
            // 3. Extract strings from DEX
            val strings = extractDEXStrings(apkPath)
            result.put("strings", strings)
            
            // 4. Detect hidden APK/DEX files in assets
            val hiddenFiles = detectHiddenExecutables(apkPath)
            result.put("hiddenExecutables", hiddenFiles)
            
            // 5. Analyze native libraries (.so files)
            val nativeLibs = analyzeNativeLibraries(apkPath)
            result.put("nativeLibraries", nativeLibs)
            
            // 6. Check for code obfuscation
            val obfuscation = detectObfuscation(apkPath)
            result.put("obfuscation", obfuscation)
            
            result.put("success", true)
        } catch (e: Exception) {
            result.put("success", false)
            result.put("error", e.message)
        }
        
        return result
    }
    
    /**
     * Compute MD5, SHA1, SHA256 hashes of APK file
     */
    private fun computeAPKHashes(apkPath: String): JSONObject {
        val hashes = JSONObject()
        val apkFile = File(apkPath)
        
        if (!apkFile.exists()) {
            return hashes
        }
        
        try {
            // Use streaming to avoid loading entire APK into memory
            val md5 = MessageDigest.getInstance("MD5")
            val sha1 = MessageDigest.getInstance("SHA-1")
            val sha256 = MessageDigest.getInstance("SHA-256")
            
            FileInputStream(apkFile).use { fis ->
                val buffer = ByteArray(8192) // 8KB buffer
                var bytesRead: Int
                
                while (fis.read(buffer).also { bytesRead = it } != -1) {
                    md5.update(buffer, 0, bytesRead)
                    sha1.update(buffer, 0, bytesRead)
                    sha256.update(buffer, 0, bytesRead)
                }
            }
            
            hashes.put("md5", bytesToHex(md5.digest()))
            hashes.put("sha1", bytesToHex(sha1.digest()))
            hashes.put("sha256", bytesToHex(sha256.digest()))
            hashes.put("fileSize", apkFile.length())
        } catch (e: Exception) {
            hashes.put("error", e.message)
        }
        
        return hashes
    }
    
    /**
     * Extract classes.dex and compute its hash
     * DEX hash is critical - even if APK is repacked, DEX hash can match known malware
     */
    private fun extractAndAnalyzeDEX(apkPath: String): JSONObject {
        val analysis = JSONObject()
        val dexHashes = JSONArray()
        
        try {
            ZipInputStream(BufferedInputStream(FileInputStream(apkPath))).use { zip ->
                var entry: ZipEntry?
                var dexCount = 0
                
                while (zip.nextEntry.also { entry = it } != null) {
                    val entryName = entry!!.name
                    
                    // Process all DEX files (classes.dex, classes2.dex, etc.)
                    if (entryName.matches(Regex("classes\\d*\\.dex"))) {
                        dexCount++
                        
                        // Read DEX file into memory
                        val dexBytes = ByteArrayOutputStream().use { baos ->
                            val buffer = ByteArray(8192)
                            var len: Int
                            while (zip.read(buffer).also { len = it } > 0) {
                                baos.write(buffer, 0, len)
                            }
                            baos.toByteArray()
                        }
                        
                        // Compute DEX hash
                        val sha256 = MessageDigest.getInstance("SHA-256")
                        val dexHash = bytesToHex(sha256.digest(dexBytes))
                        
                        val dexInfo = JSONObject()
                        dexInfo.put("name", entryName)
                        dexInfo.put("sha256", dexHash)
                        dexInfo.put("size", dexBytes.size)
                        
                        // Parse DEX header
                        val dexHeader = parseDEXHeader(dexBytes)
                        dexInfo.put("header", dexHeader)
                        
                        dexHashes.put(dexInfo)
                    }
                    
                    zip.closeEntry()
                }
                
                analysis.put("dexCount", dexCount)
                analysis.put("dexFiles", dexHashes)
            }
        } catch (e: Exception) {
            analysis.put("error", e.message)
        }
        
        return analysis
    }
    
    /**
     * Parse DEX file header to extract metadata
     * DEX format: https://source.android.com/docs/core/runtime/dex-format
     */
    private fun parseDEXHeader(dexBytes: ByteArray): JSONObject {
        val header = JSONObject()
        
        try {
            // DEX magic: "dex\n035\0" or "dex\n036\0" etc.
            val magic = String(dexBytes.copyOfRange(0, 8))
            header.put("magic", magic)
            
            // DEX version
            val version = magic.substring(4, 7)
            header.put("version", version)
            
            // File size (bytes 32-35, little-endian)
            val fileSize = readLittleEndianInt(dexBytes, 32)
            header.put("fileSize", fileSize)
            
            // String IDs count (bytes 56-59)
            val stringIdsSize = readLittleEndianInt(dexBytes, 56)
            header.put("stringCount", stringIdsSize)
            
            // Type IDs count (bytes 60-63)
            val typeIdsSize = readLittleEndianInt(dexBytes, 60)
            header.put("typeCount", typeIdsSize)
            
            // Method IDs count (bytes 88-91)
            val methodIdsSize = readLittleEndianInt(dexBytes, 88)
            header.put("methodCount", methodIdsSize)
            
            // Class defs count (bytes 96-99)
            val classDefsSize = readLittleEndianInt(dexBytes, 96)
            header.put("classCount", classDefsSize)
            
        } catch (e: Exception) {
            header.put("error", e.message)
        }
        
        return header
    }
    
    /**
     * Extract strings from DEX file
     * These strings can reveal:
     * - Hardcoded URLs (C2 servers)
     * - Shell commands (su, chmod, etc.)
     * - API endpoints
     * - Obfuscated code patterns
     */
    private fun extractDEXStrings(apkPath: String): JSONObject {
        val result = JSONObject()
        val suspiciousStrings = JSONArray()
        val allStrings = mutableSetOf<String>()
        
        try {
            ZipInputStream(BufferedInputStream(FileInputStream(apkPath))).use { zip ->
                var entry: ZipEntry?
                
                while (zip.nextEntry.also { entry = it } != null) {
                    val entryName = entry!!.name
                    
                    if (entryName.matches(Regex("classes\\d*\\.dex"))) {
                        // Read DEX
                        val dexBytes = ByteArrayOutputStream().use { baos ->
                            val buffer = ByteArray(8192)
                            var len: Int
                            while (zip.read(buffer).also { len = it } > 0) {
                                baos.write(buffer, 0, len)
                            }
                            baos.toByteArray()
                        }
                        
                        // Extract strings from DEX
                        val strings = extractStringsFromDEX(dexBytes)
                        allStrings.addAll(strings)
                    }
                    
                    zip.closeEntry()
                }
            }
            
            // Analyze strings for suspicious patterns
            val suspiciousPatterns = listOf(
                Regex(".*\\bsu\\b.*", RegexOption.IGNORE_CASE),
                Regex(".*\\broot\\b.*", RegexOption.IGNORE_CASE),
                Regex(".*\\/system\\/bin\\/.*"),
                Regex(".*\\/system\\/xbin\\/.*"),
                Regex("http://\\d+\\.\\d+\\.\\d+\\.\\d+.*"),  // Direct IP URLs
                Regex(".*exec.*", RegexOption.IGNORE_CASE),
                Regex(".*ProcessBuilder.*"),
                Regex(".*Runtime\\.getRuntime.*"),
                Regex(".*\\.sendTextMessage.*"),
                Regex(".*DevicePolicyManager.*"),
                Regex(".*AccessibilityService.*"),
                Regex(".*\\.onAccessibilityEvent.*")
            )
            
            for (str in allStrings) {
                for (pattern in suspiciousPatterns) {
                    if (pattern.matches(str)) {
                        suspiciousStrings.put(str)
                        break
                    }
                }
            }
            
            result.put("totalStrings", allStrings.size)
            result.put("suspiciousStrings", suspiciousStrings)
            result.put("suspiciousCount", suspiciousStrings.length())
            
        } catch (e: Exception) {
            result.put("error", e.message)
        }
        
        return result
    }
    
    /**
     * Extract strings from DEX bytecode
     * Parses string_ids section of DEX file
     */
    private fun extractStringsFromDEX(dexBytes: ByteArray): List<String> {
        val strings = mutableListOf<String>()
        
        try {
            // Read string IDs count and offset from header
            val stringIdsSize = readLittleEndianInt(dexBytes, 56)
            val stringIdsOff = readLittleEndianInt(dexBytes, 60)
            
            // Each string_id_item is 4 bytes (offset to string_data_item)
            for (i in 0 until stringIdsSize) {
                val stringDataOff = readLittleEndianInt(dexBytes, stringIdsOff + i * 4)
                
                // Read string from string_data_item
                val str = readUTF8String(dexBytes, stringDataOff)
                if (str.isNotEmpty() && str.length < 1000) {  // Filter out huge strings
                    strings.add(str)
                }
            }
        } catch (e: Exception) {
            // DEX parsing can fail on malformed files
        }
        
        return strings
    }
    
    /**
     * Detect hidden executables in APK assets
     * Malware often hides additional DEX/JAR/APK files in assets folder
     */
    private fun detectHiddenExecutables(apkPath: String): JSONArray {
        val hiddenFiles = JSONArray()
        
        try {
            ZipInputStream(BufferedInputStream(FileInputStream(apkPath))).use { zip ->
                var entry: ZipEntry?
                
                while (zip.nextEntry.also { entry = it } != null) {
                    val entryName = entry!!.name
                    
                    // Check for suspicious files in assets/
                    if (entryName.startsWith("assets/") || entryName.startsWith("res/raw/")) {
                        val suspicious = entryName.endsWith(".dex") ||
                                       entryName.endsWith(".jar") ||
                                       entryName.endsWith(".apk") ||
                                       entryName.endsWith(".so") ||
                                       entryName.endsWith(".zip")
                        
                        if (suspicious) {
                            val fileInfo = JSONObject()
                            fileInfo.put("path", entryName)
                            fileInfo.put("size", entry!!.size)
                            hiddenFiles.put(fileInfo)
                        }
                    }
                    
                    zip.closeEntry()
                }
            }
        } catch (e: Exception) {
            // Ignore
        }
        
        return hiddenFiles
    }
    
    /**
     * Analyze native libraries (.so files)
     * Check for suspicious native code
     */
    private fun analyzeNativeLibraries(apkPath: String): JSONArray {
        val libs = JSONArray()
        
        try {
            ZipInputStream(BufferedInputStream(FileInputStream(apkPath))).use { zip ->
                var entry: ZipEntry?
                
                while (zip.nextEntry.also { entry = it } != null) {
                    val entryName = entry!!.name
                    
                    if (entryName.startsWith("lib/") && entryName.endsWith(".so")) {
                        val libInfo = JSONObject()
                        libInfo.put("name", entryName)
                        libInfo.put("size", entry!!.size)
                        
                        // Check for suspicious library names
                        val suspicious = entryName.contains("inject") ||
                                       entryName.contains("hook") ||
                                       entryName.contains("root") ||
                                       entryName.contains("xposed")
                        
                        libInfo.put("suspicious", suspicious)
                        libs.put(libInfo)
                    }
                    
                    zip.closeEntry()
                }
            }
        } catch (e: Exception) {
            // Ignore
        }
        
        return libs
    }
    
    /**
     * Detect code obfuscation indicators
     * Obfuscated apps often hide malicious functionality
     */
    private fun detectObfuscation(apkPath: String): JSONObject {
        val obfuscation = JSONObject()
        
        try {
            ZipInputStream(BufferedInputStream(FileInputStream(apkPath))).use { zip ->
                var entry: ZipEntry?
                var shortClassNames = 0
                var totalClasses = 0
                
                while (zip.nextEntry.also { entry = it } != null) {
                    val entryName = entry!!.name
                    
                    if (entryName.matches(Regex("classes\\d*\\.dex"))) {
                        val dexBytes = ByteArrayOutputStream().use { baos ->
                            val buffer = ByteArray(8192)
                            var len: Int
                            while (zip.read(buffer).also { len = it } > 0) {
                                baos.write(buffer, 0, len)
                            }
                            baos.toByteArray()
                        }
                        
                        // Count short class names (indicator of ProGuard/R8)
                        val strings = extractStringsFromDEX(dexBytes)
                        for (str in strings) {
                            if (str.matches(Regex("L[a-z]/[a-z];"))) {
                                shortClassNames++
                            }
                            if (str.startsWith("L") && str.endsWith(";")) {
                                totalClasses++
                            }
                        }
                    }
                    
                    zip.closeEntry()
                }
                
                val obfuscationRatio = if (totalClasses > 0) {
                    (shortClassNames.toDouble() / totalClasses.toDouble()) * 100
                } else {
                    0.0
                }
                
                obfuscation.put("shortClassNames", shortClassNames)
                obfuscation.put("totalClasses", totalClasses)
                obfuscation.put("obfuscationRatio", obfuscationRatio)
                obfuscation.put("isObfuscated", obfuscationRatio > 30.0)
            }
        } catch (e: Exception) {
            obfuscation.put("error", e.message)
        }
        
        return obfuscation
    }
    
    // ======================== Utility Functions ========================
    
    private fun readLittleEndianInt(bytes: ByteArray, offset: Int): Int {
        return (bytes[offset].toInt() and 0xFF) or
               ((bytes[offset + 1].toInt() and 0xFF) shl 8) or
               ((bytes[offset + 2].toInt() and 0xFF) shl 16) or
               ((bytes[offset + 3].toInt() and 0xFF) shl 24)
    }
    
    private fun readUTF8String(bytes: ByteArray, offset: Int): String {
        var pos = offset
        
        // Read ULEB128 size
        var size = 0
        var shift = 0
        var b: Int
        
        do {
            b = bytes[pos++].toInt() and 0xFF
            size = size or ((b and 0x7F) shl shift)
            shift += 7
        } while (b and 0x80 != 0)
        
        // Read UTF-8 string
        return try {
            String(bytes, pos, size, Charsets.UTF_8)
        } catch (e: Exception) {
            ""
        }
    }
    
    private fun bytesToHex(bytes: ByteArray): String {
        val hexChars = CharArray(bytes.size * 2)
        for (i in bytes.indices) {
            val v = bytes[i].toInt() and 0xFF
            hexChars[i * 2] = "0123456789abcdef"[v ushr 4]
            hexChars[i * 2 + 1] = "0123456789abcdef"[v and 0x0F]
        }
        return String(hexChars)
    }
}
