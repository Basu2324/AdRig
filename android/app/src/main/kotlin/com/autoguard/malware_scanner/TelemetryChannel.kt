package com.autoguard.malware_scanner

import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageInfo
import android.content.pm.ApplicationInfo
import android.os.Build
import android.util.Log
import io.flutter.plugin.common.MethodChannel
import java.io.File
import java.security.MessageDigest

class TelemetryChannel(private val context: Context) {
    
    companion object {
        const val CHANNEL_NAME = "com.adrig.security/telemetry"
        private const val TAG = "AdRig_Telemetry"
    }
    
    fun setupMethodChannel(channel: MethodChannel) {
        channel.setMethodCallHandler { call, result ->
            when (call.method) {
                "getInstalledApps" -> {
                    try {
                        val apps = getInstalledApps()
                        result.success(apps)
                    } catch (e: Exception) {
                        result.error("GET_APPS_ERROR", e.message, null)
                    }
                }
                "getAppDetails" -> {
                    try {
                        val packageName = call.argument<String>("packageName")
                        if (packageName != null) {
                            val details = getAppDetails(packageName)
                            result.success(details)
                        } else {
                            result.error("INVALID_ARGUMENT", "Package name is required", null)
                        }
                    } catch (e: Exception) {
                        result.error("GET_APP_DETAILS_ERROR", e.message, null)
                    }
                }
                "scanFiles" -> {
                    try {
                        val path = call.argument<String>("path") ?: "/"
                        val files = scanFiles(path)
                        result.success(files)
                    } catch (e: Exception) {
                        result.error("SCAN_FILES_ERROR", e.message, null)
                    }
                }
                "getRunningProcesses" -> {
                    try {
                        val processes = getRunningProcesses()
                        result.success(processes)
                    } catch (e: Exception) {
                        result.error("GET_PROCESSES_ERROR", e.message, null)
                    }
                }
                "checkRootAccess" -> {
                    try {
                        val rootInfo = checkRootAccess()
                        result.success(rootInfo)
                    } catch (e: Exception) {
                        result.error("CHECK_ROOT_ERROR", e.message, null)
                    }
                }
                "analyzeAPK" -> {
                    try {
                        val packageName = call.argument<String>("packageName")
                        if (packageName != null) {
                            val analyzer = APKAnalyzer(context)
                            val analysis = analyzer.analyzeAPK(packageName)
                            result.success(analysis.toString())
                        } else {
                            result.error("INVALID_ARGUMENT", "Package name is required", null)
                        }
                    } catch (e: Exception) {
                        result.error("ANALYZE_APK_ERROR", e.message, null)
                    }
                }
                else -> result.notImplemented()
            }
        }
    }
    
    private fun getInstalledApps(): List<Map<String, Any?>> {
        Log.d(TAG, "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        Log.d(TAG, "getInstalledApps() START")
        Log.d(TAG, "Android Version: ${Build.VERSION.SDK_INT}")
        Log.d(TAG, "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        
        val apps = mutableListOf<Map<String, Any?>>()
        val pm = context.packageManager
        
        try {
            Log.d(TAG, "Attempting to get all installed packages...")
            
            // Try to get all packages
            val packages = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                pm.getInstalledPackages(PackageManager.PackageInfoFlags.of(
                    PackageManager.GET_PERMISSIONS.toLong()
                ))
            } else {
                @Suppress("DEPRECATION")
                pm.getInstalledPackages(PackageManager.GET_PERMISSIONS)
            }
            
            Log.d(TAG, "‚úÖ Found ${packages.size} packages")
            
            if (packages.size < 10) {
                Log.w(TAG, "‚ö†Ô∏è  WARNING: Only ${packages.size} packages found!")
                Log.w(TAG, "This likely means QUERY_ALL_PACKAGES permission is denied")
                Log.w(TAG, "Will use launcher apps fallback after processing these")
            }
            
            for (packageInfo in packages) {
                try {
                    val appInfo = packageInfo.applicationInfo ?: continue
                    
                    // Skip our own app during scanning
                    if (packageInfo.packageName == context.packageName) {
                        continue
                    }
                    
                    val appData = mapOf(
                        "packageName" to packageInfo.packageName,
                        "appName" to pm.getApplicationLabel(appInfo).toString(),
                        "version" to (packageInfo.versionName ?: ""),
                        "versionCode" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                            packageInfo.longVersionCode
                        } else {
                            @Suppress("DEPRECATION")
                            packageInfo.versionCode.toLong()
                        },
                        "installer" to (pm.getInstallerPackageName(packageInfo.packageName) ?: "unknown"),
                        "installTime" to packageInfo.firstInstallTime,
                        "updateTime" to packageInfo.lastUpdateTime,
                        "isSystemApp" to ((appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0),
                        "apkPath" to (appInfo.sourceDir ?: ""),
                        "dataDir" to (appInfo.dataDir ?: ""),
                        "permissions" to (packageInfo.requestedPermissions?.toList() ?: emptyList<String>())
                    )
                    apps.add(appData)
                } catch (e: Exception) {
                    Log.w(TAG, "Error processing package: ${e.message}")
                    continue
                }
            }
            
            Log.d(TAG, "‚úÖ Successfully collected ${apps.size} apps")
            
            // If we got very few apps, probably filtered - use launcher fallback
            if (apps.size < 10 && Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                Log.w(TAG, "‚ö†Ô∏è  Too few apps (${apps.size}) on Android 11+ - using launcher fallback")
                apps.clear()
                throw SecurityException("Insufficient apps - likely permission issue")
            }
            
        } catch (e: SecurityException) {
            // QUERY_ALL_PACKAGES permission not granted
            Log.e(TAG, "‚ùå SecurityException - QUERY_ALL_PACKAGES not granted")
            Log.d(TAG, "üîÑ Falling back to launcher apps only...")
            
            // Fallback: Get only launcher apps (visible in app drawer)
            val mainIntent = android.content.Intent(android.content.Intent.ACTION_MAIN, null)
            mainIntent.addCategory(android.content.Intent.CATEGORY_LAUNCHER)
            
            val launcherApps = pm.queryIntentActivities(mainIntent, 0)
            Log.d(TAG, "üì± Found ${launcherApps.size} launcher apps")
            
            for (resolveInfo in launcherApps) {
                try {
                    val packageName = resolveInfo.activityInfo.packageName
                    
                    // Skip our own app
                    if (packageName == context.packageName) {
                        continue
                    }
                    
                    val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                        pm.getPackageInfo(packageName, PackageManager.PackageInfoFlags.of(
                            PackageManager.GET_PERMISSIONS.toLong()
                        ))
                    } else {
                        @Suppress("DEPRECATION")
                        pm.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS)
                    }
                    
                    val appInfo = packageInfo.applicationInfo ?: continue
                    
                    val appData = mapOf(
                        "packageName" to packageName,
                        "appName" to pm.getApplicationLabel(appInfo).toString(),
                        "version" to (packageInfo.versionName ?: ""),
                        "versionCode" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                            packageInfo.longVersionCode
                        } else {
                            @Suppress("DEPRECATION")
                            packageInfo.versionCode.toLong()
                        },
                        "installer" to (pm.getInstallerPackageName(packageName) ?: "unknown"),
                        "installTime" to packageInfo.firstInstallTime,
                        "updateTime" to packageInfo.lastUpdateTime,
                        "isSystemApp" to ((appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0),
                        "apkPath" to (appInfo.sourceDir ?: ""),
                        "dataDir" to (appInfo.dataDir ?: ""),
                        "permissions" to (packageInfo.requestedPermissions?.toList() ?: emptyList<String>())
                    )
                    apps.add(appData)
                } catch (e: Exception) {
                    Log.w(TAG, "Error processing launcher app: ${e.message}")
                    continue
                }
            }
            
            Log.d(TAG, "‚úÖ Successfully collected ${apps.size} launcher apps (fallback mode)")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Unexpected error: ${e.message}")
            e.printStackTrace()
        }
        
        Log.d(TAG, "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        Log.d(TAG, "getInstalledApps() RETURNING ${apps.size} apps")
        Log.d(TAG, "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        
        return apps
    }
    
    private fun getAppDetails(packageName: String): Map<String, Any?> {
        val pm = context.packageManager
        
        val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            pm.getPackageInfo(packageName, PackageManager.PackageInfoFlags.of(
                (PackageManager.GET_PERMISSIONS or 
                 PackageManager.GET_ACTIVITIES or
                 PackageManager.GET_SERVICES or
                 PackageManager.GET_RECEIVERS or
                 PackageManager.GET_PROVIDERS).toLong()
            ))
        } else {
            @Suppress("DEPRECATION")
            pm.getPackageInfo(packageName, 
                PackageManager.GET_PERMISSIONS or 
                PackageManager.GET_ACTIVITIES or
                PackageManager.GET_SERVICES or
                PackageManager.GET_RECEIVERS or
                PackageManager.GET_PROVIDERS
            )
        }
        
        val appInfo = packageInfo.applicationInfo ?: return emptyMap()
        val apkPath = appInfo.sourceDir ?: return emptyMap()
        val apkFile = File(apkPath)
        
        // Calculate APK hashes
        val hashes = calculateFileHashes(apkFile)
        
        // Get signing certificate
        val signingCert = getSigningCertificate(packageName)
        
        return mapOf(
            "packageName" to packageName,
            "appName" to pm.getApplicationLabel(appInfo).toString(),
            "version" to (packageInfo.versionName ?: ""),
            "versionCode" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                packageInfo.longVersionCode
            } else {
                @Suppress("DEPRECATION")
                packageInfo.versionCode.toLong()
            },
            "installer" to pm.getInstallerPackageName(packageName),
            "installTime" to packageInfo.firstInstallTime,
            "updateTime" to packageInfo.lastUpdateTime,
            "apkPath" to apkPath,
            "apkSize" to apkFile.length(),
            "dataDir" to (appInfo.dataDir ?: ""),
            "nativeLibraryDir" to (appInfo.nativeLibraryDir ?: ""),
            "isSystemApp" to ((appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0),
            "targetSdk" to appInfo.targetSdkVersion,
            "minSdk" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                appInfo.minSdkVersion
            } else {
                0
            },
            "permissions" to (packageInfo.requestedPermissions?.toList() ?: emptyList<String>()),
            "activities" to (packageInfo.activities?.map { it.name } ?: emptyList<String>()),
            "services" to (packageInfo.services?.map { it.name } ?: emptyList<String>()),
            "receivers" to (packageInfo.receivers?.map { it.name } ?: emptyList<String>()),
            "providers" to (packageInfo.providers?.map { it.name } ?: emptyList<String>()),
            "md5" to hashes["md5"],
            "sha1" to hashes["sha1"],
            "sha256" to hashes["sha256"],
            "signingCert" to signingCert
        )
    }
    
    private fun calculateFileHashes(file: File): Map<String, String> {
        val hashes = mutableMapOf<String, String>()
        
        try {
            val bytes = file.readBytes()
            
            // MD5
            val md5 = MessageDigest.getInstance("MD5")
            hashes["md5"] = md5.digest(bytes).toHexString()
            
            // SHA1
            val sha1 = MessageDigest.getInstance("SHA-1")
            hashes["sha1"] = sha1.digest(bytes).toHexString()
            
            // SHA256
            val sha256 = MessageDigest.getInstance("SHA-256")
            hashes["sha256"] = sha256.digest(bytes).toHexString()
        } catch (e: Exception) {
            hashes["md5"] = ""
            hashes["sha1"] = ""
            hashes["sha256"] = ""
        }
        
        return hashes
    }
    
    private fun getSigningCertificate(packageName: String): String {
        val pm = context.packageManager
        
        try {
            val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                pm.getPackageInfo(packageName, PackageManager.PackageInfoFlags.of(
                    PackageManager.GET_SIGNING_CERTIFICATES.toLong()
                ))
            } else {
                @Suppress("DEPRECATION")
                pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES)
            }
            
            val signatures = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                packageInfo.signingInfo?.apkContentsSigners
            } else {
                @Suppress("DEPRECATION")
                packageInfo.signatures
            }
            
            if (signatures != null && signatures.isNotEmpty()) {
                val cert = signatures[0].toByteArray()
                val sha256 = MessageDigest.getInstance("SHA-256")
                return sha256.digest(cert).toHexString()
            }
        } catch (e: Exception) {
            // Ignore
        }
        
        return ""
    }
    
    private fun scanFiles(rootPath: String): List<Map<String, Any?>> {
        val files = mutableListOf<Map<String, Any?>>()
        val root = File(rootPath)
        
        if (!root.exists() || !root.canRead()) {
            return files
        }
        
        try {
            root.walkTopDown()
                .maxDepth(5) // Limit recursion depth
                .take(1000) // Limit total files scanned
                .filter { it.isFile }
                .forEach { file ->
                    try {
                        val fileData = mapOf(
                            "path" to file.absolutePath,
                            "name" to file.name,
                            "size" to file.length(),
                            "modified" to file.lastModified(),
                            "created" to file.lastModified(), // Android doesn't track creation time
                            "accessed" to file.lastModified(),
                            "permissions" to file.canRead().toString() + file.canWrite().toString() + file.canExecute().toString(),
                            "owner" to "system" // Would require advanced permissions
                        )
                        files.add(fileData)
                    } catch (e: Exception) {
                        // Skip files that can't be accessed
                    }
                }
        } catch (e: Exception) {
            // Handle permission denied or other errors
        }
        
        return files
    }
    
    private fun getRunningProcesses(): List<Map<String, Any?>> {
        val processes = mutableListOf<Map<String, Any?>>()
        
        try {
            val procDir = File("/proc")
            if (procDir.exists() && procDir.isDirectory) {
                procDir.listFiles()?.forEach { file ->
                    if (file.isDirectory && file.name.matches(Regex("\\d+"))) {
                        try {
                            val pid = file.name.toIntOrNull() ?: return@forEach
                            val cmdlineFile = File(file, "cmdline")
                            val name = if (cmdlineFile.exists()) {
                                cmdlineFile.readText().replace("\u0000", " ").trim()
                            } else {
                                "unknown"
                            }
                            
                            if (name.isNotEmpty()) {
                                val processData: Map<String, Any> = mapOf(
                                    "pid" to pid,
                                    "name" to name,
                                    "packageName" to (name.split(" ").firstOrNull() ?: "unknown"),
                                    "uid" to 0,
                                    "cpuUsage" to 0.0,
                                    "memoryUsage" to 0L,
                                    "threadCount" to 1,
                                    "startTime" to System.currentTimeMillis(),
                                    "ppid" to 0
                                )
                                processes.add(processData)
                            }
                        } catch (e: Exception) {
                            // Skip processes we can't read
                        }
                    }
                }
            }
        } catch (e: Exception) {
            // Handle errors
        }
        
        return processes
    }
    
    private fun checkRootAccess(): Map<String, Any> {
        val indicators = mutableListOf<Map<String, String>>()
        
        // Check for su binary
        val suPaths = listOf(
            "/system/bin/su",
            "/system/xbin/su",
            "/sbin/su",
            "/system/su",
            "/data/local/xbin/su"
        )
        
        var suFound = false
        var suPath = ""
        for (path in suPaths) {
            if (File(path).exists()) {
                suFound = true
                suPath = path
                indicators.add(mapOf(
                    "type" to "SU_BINARY",
                    "path" to path,
                    "description" to "SuperUser binary found"
                ))
                break
            }
        }
        
        // Check for root apps
        val rootApps = mutableListOf<String>()
        val rootAppPackages = listOf(
            "com.topjohnwu.magisk",
            "eu.chainfire.supersu",
            "com.noshufou.android.su"
        )
        
        val pm = context.packageManager
        for (pkg in rootAppPackages) {
            try {
                pm.getPackageInfo(pkg, 0)
                rootApps.add(pkg)
                indicators.add(mapOf(
                    "type" to "ROOT_APP",
                    "path" to pkg,
                    "description" to "Root management app installed"
                ))
            } catch (e: Exception) {
                // App not installed
            }
        }
        
        // Check build properties
        val buildTags = Build.TAGS
        val testKeys = buildTags != null && buildTags.contains("test-keys")
        if (testKeys) {
            indicators.add(mapOf(
                "type" to "BUILD_TAGS",
                "path" to "Build.TAGS",
                "description" to "Device built with test-keys"
            ))
        }
        
        return mapOf(
            "suBinaryFound" to suFound,
            "suPath" to suPath,
            "rootApps" to rootApps,
            "testKeys" to testKeys,
            "isRooted" to (indicators.isNotEmpty()),
            "indicators" to indicators
        )
    }
    
    private fun ByteArray.toHexString(): String {
        return joinToString("") { "%02x".format(it) }
    }
}
