package com.autoguard.malware_scanner

import android.app.ActivityManager
import android.content.Context
import android.os.FileObserver
import android.util.Log
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.io.BufferedReader
import java.io.InputStreamReader

/**
 * Production behavioral monitoring engine
 * Monitors runtime behavior for malicious activities:
 * - Process execution (Runtime.exec, su, root)
 * - File system access to sensitive paths
 * - Network connections to suspicious IPs/domains
 * - Inter-process communication
 */
class BehavioralMonitor(private val context: Context) {
    
    private val TAG = "BehavioralMonitor"
    private val suspiciousActivities = mutableListOf<SuspiciousActivity>()
    private var fileObserver: FileObserver? = null
    
    /**
     * Start behavioral monitoring
     */
    fun startMonitoring() {
        Log.d(TAG, "ðŸ” Starting behavioral monitoring")
        
        // Monitor sensitive file system paths
        startFileSystemMonitoring()
        
        // Monitor running processes
        startProcessMonitoring()
    }
    
    /**
     * Stop behavioral monitoring
     */
    fun stopMonitoring() {
        fileObserver?.stopWatching()
        Log.d(TAG, "â¸ï¸  Stopped behavioral monitoring")
    }
    
    /**
     * Get detected suspicious activities
     */
    fun getSuspiciousActivities(): JSONArray {
        val activities = JSONArray()
        
        for (activity in suspiciousActivities) {
            activities.put(activity.toJSON())
        }
        
        return activities
    }
    
    /**
     * Monitor file system for suspicious access patterns
     */
    private fun startFileSystemMonitoring() {
        try {
            // Monitor /system for modifications (root indicator)
            val systemPaths = listOf(
                "/system/bin",
                "/system/xbin",
                "/system/app"
            )
            
            for (path in systemPaths) {
                val dir = File(path)
                if (dir.exists() && dir.canRead()) {
                    monitorDirectory(path)
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error starting file system monitoring: ${e.message}")
        }
    }
    
    /**
     * Monitor a directory for changes
     */
    private fun monitorDirectory(path: String) {
        // Note: FileObserver requires root access for system directories
        // This is a simplified implementation for demonstration
        try {
            val observer = object : FileObserver(path, ALL_EVENTS) {
                override fun onEvent(event: Int, path: String?) {
                    when (event) {
                        CREATE -> {
                            reportActivity(
                                "FILE_CREATION",
                                "File created in protected directory: $path",
                                SeverityLevel.HIGH
                            )
                        }
                        MODIFY -> {
                            reportActivity(
                                "FILE_MODIFICATION",
                                "File modified in protected directory: $path",
                                SeverityLevel.HIGH
                            )
                        }
                        DELETE -> {
                            reportActivity(
                                "FILE_DELETION",
                                "File deleted from protected directory: $path",
                                SeverityLevel.MEDIUM
                            )
                        }
                    }
                }
            }
            
            observer.startWatching()
            fileObserver = observer
        } catch (e: Exception) {
            Log.e(TAG, "Error monitoring directory $path: ${e.message}")
        }
    }
    
    /**
     * Monitor running processes for suspicious patterns
     */
    private fun startProcessMonitoring() {
        Thread {
            while (true) {
                try {
                    checkRunningProcesses()
                    Thread.sleep(5000) // Check every 5 seconds
                } catch (e: InterruptedException) {
                    break
                } catch (e: Exception) {
                    Log.e(TAG, "Error in process monitoring: ${e.message}")
                }
            }
        }.start()
    }
    
    /**
     * Check running processes for suspicious activity
     */
    private fun checkRunningProcesses() {
        try {
            val am = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
            val runningApps = am.runningAppProcesses ?: return
            
            for (processInfo in runningApps) {
                // Check for suspicious process names
                if (isSuspiciousProcess(processInfo.processName)) {
                    reportActivity(
                        "SUSPICIOUS_PROCESS",
                        "Suspicious process running: ${processInfo.processName}",
                        SeverityLevel.HIGH
                    )
                }
                
                // Check for excessive CPU/memory usage
                checkResourceUsage(processInfo)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error checking processes: ${e.message}")
        }
    }
    
    /**
     * Check if process name is suspicious
     */
    private fun isSuspiciousProcess(processName: String): Boolean {
        val suspiciousKeywords = listOf(
            "su",
            "root",
            "magisk",
            "xposed",
            "supersu",
            "daemonsu",
            "inject",
            "hook",
            "dump",
            "exploit"
        )
        
        val lowerName = processName.lowercase()
        return suspiciousKeywords.any { lowerName.contains(it) }
    }
    
    /**
     * Check resource usage of a process
     */
    private fun checkResourceUsage(processInfo: ActivityManager.RunningAppProcessInfo) {
        try {
            val pid = processInfo.pid
            
            // Read /proc/[pid]/stat for CPU info
            val statFile = File("/proc/$pid/stat")
            if (statFile.exists()) {
                val stats = statFile.readText().split(" ")
                
                // CPU time is at index 13 and 14 (utime and stime)
                if (stats.size > 14) {
                    val utime = stats[13].toLongOrNull() ?: 0
                    val stime = stats[14].toLongOrNull() ?: 0
                    val totalTime = utime + stime
                    
                    // If process is using excessive CPU (simplified check)
                    if (totalTime > 1000000) { // Arbitrary threshold
                        reportActivity(
                            "HIGH_CPU_USAGE",
                            "Process ${processInfo.processName} using excessive CPU",
                            SeverityLevel.MEDIUM
                        )
                    }
                }
            }
        } catch (e: Exception) {
            // Ignore - process may have terminated
        }
    }
    
    /**
     * Monitor network connections
     */
    fun checkNetworkConnections(packageName: String): JSONArray {
        val connections = JSONArray()
        
        try {
            // Read /proc/net/tcp and /proc/net/tcp6
            val tcpConnections = readNetworkFile("/proc/net/tcp")
            val tcp6Connections = readNetworkFile("/proc/net/tcp6")
            
            // Parse connections and check for suspicious IPs/ports
            for (conn in tcpConnections + tcp6Connections) {
                if (isSuspiciousConnection(conn)) {
                    connections.put(conn.toJSON())
                    
                    reportActivity(
                        "SUSPICIOUS_NETWORK",
                        "Suspicious network connection detected: ${conn.remoteAddress}:${conn.remotePort}",
                        SeverityLevel.HIGH
                    )
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error checking network connections: ${e.message}")
        }
        
        return connections
    }
    
    /**
     * Read network connection file from /proc
     */
    private fun readNetworkFile(path: String): List<NetworkConnection> {
        val connections = mutableListOf<NetworkConnection>()
        
        try {
            val file = File(path)
            if (!file.exists()) return connections
            
            file.forEachLine { line ->
                // Parse /proc/net/tcp format
                // Format: sl local_address rem_address st tx_queue rx_queue tr tm->when retrnsmt uid timeout inode
                val parts = line.trim().split(Regex("\\s+"))
                
                if (parts.size >= 10 && parts[0] != "sl") {
                    try {
                        val localAddr = parseAddress(parts[1])
                        val remoteAddr = parseAddress(parts[2])
                        val state = parts[3]
                        val uid = parts[7].toIntOrNull() ?: -1
                        
                        connections.add(
                            NetworkConnection(
                                localAddress = localAddr.first,
                                localPort = localAddr.second,
                                remoteAddress = remoteAddr.first,
                                remotePort = remoteAddr.second,
                                state = state,
                                uid = uid
                            )
                        )
                    } catch (e: Exception) {
                        // Skip malformed lines
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error reading $path: ${e.message}")
        }
        
        return connections
    }
    
    /**
     * Parse address from /proc/net/tcp format (hex)
     */
    private fun parseAddress(addressPort: String): Pair<String, Int> {
        val parts = addressPort.split(":")
        if (parts.size != 2) return Pair("0.0.0.0", 0)
        
        try {
            val addrHex = parts[0]
            val portHex = parts[1]
            
            // Convert hex to IP (little-endian)
            val addr = "${
                Integer.parseInt(addrHex.substring(6, 8), 16)
            }.${
                Integer.parseInt(addrHex.substring(4, 6), 16)
            }.${
                Integer.parseInt(addrHex.substring(2, 4), 16)
            }.${
                Integer.parseInt(addrHex.substring(0, 2), 16)
            }"
            
            val port = Integer.parseInt(portHex, 16)
            
            return Pair(addr, port)
        } catch (e: Exception) {
            return Pair("0.0.0.0", 0)
        }
    }
    
    /**
     * Check if connection is suspicious
     */
    private fun isSuspiciousConnection(conn: NetworkConnection): Boolean {
        // Check for connections to suspicious ports
        val suspiciousPorts = setOf(
            4444, // Metasploit default
            5555, // Android Debug Bridge
            6666, // IRC/Trojan
            31337, // Back Orifice
            12345, // NetBus
        )
        
        if (suspiciousPorts.contains(conn.remotePort)) {
            return true
        }
        
        // Check for connections to non-standard IPs (not in private ranges)
        // This is a simplified check
        val ip = conn.remoteAddress
        if (!ip.startsWith("192.168.") &&
            !ip.startsWith("10.") &&
            !ip.startsWith("172.") &&
            !ip.startsWith("127.") &&
            ip != "0.0.0.0"
        ) {
            return true
        }
        
        return false
    }
    
    /**
     * Report suspicious activity
     */
    private fun reportActivity(type: String, description: String, severity: SeverityLevel) {
        val activity = SuspiciousActivity(
            type = type,
            description = description,
            severity = severity,
            timestamp = System.currentTimeMillis()
        )
        
        suspiciousActivities.add(activity)
        Log.w(TAG, "âš ï¸  SUSPICIOUS: $type - $description")
        
        // Keep only last 1000 activities to prevent memory issues
        if (suspiciousActivities.size > 1000) {
            suspiciousActivities.removeAt(0)
        }
    }
    
    // ==================== Data Classes ====================
    
    data class SuspiciousActivity(
        val type: String,
        val description: String,
        val severity: SeverityLevel,
        val timestamp: Long
    ) {
        fun toJSON(): JSONObject {
            return JSONObject().apply {
                put("type", type)
                put("description", description)
                put("severity", severity.name)
                put("timestamp", timestamp)
            }
        }
    }
    
    data class NetworkConnection(
        val localAddress: String,
        val localPort: Int,
        val remoteAddress: String,
        val remotePort: Int,
        val state: String,
        val uid: Int
    ) {
        fun toJSON(): JSONObject {
            return JSONObject().apply {
                put("localAddress", localAddress)
                put("localPort", localPort)
                put("remoteAddress", remoteAddress)
                put("remotePort", remotePort)
                put("state", state)
                put("uid", uid)
            }
        }
    }
    
    enum class SeverityLevel {
        LOW, MEDIUM, HIGH, CRITICAL
    }
}
