package com.autoguard.malware_scanner

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import android.os.Build
import kotlinx.coroutines.*
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
import org.json.JSONArray
import org.json.JSONObject

/**
 * Real-time network traffic monitor for detecting:
 * - C2 (Command & Control) communication patterns
 * - Data exfiltration attempts
 * - Connections to known malicious IPs/domains
 * - Suspicious DNS queries
 * - Abnormal traffic patterns
 */
class NetworkMonitor(private val context: Context) {
    
    private val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    // Known malicious IP ranges and domains (updated from threat intel)
    private val maliciousIPs = mutableSetOf<String>()
    private val maliciousDomains = mutableSetOf<String>()
    
    // Network activity statistics
    private val networkStats = mutableMapOf<String, NetworkActivity>()
    
    data class NetworkActivity(
        var connectionCount: Int = 0,
        var bytesTransferred: Long = 0,
        var suspiciousConnections: Int = 0,
        var lastSeen: Long = System.currentTimeMillis()
    )
    
    data class NetworkThreat(
        val packageName: String,
        val type: ThreatType,
        val destination: String,
        val description: String,
        val severity: String,
        val timestamp: Long = System.currentTimeMillis()
    )
    
    enum class ThreatType {
        C2_COMMUNICATION,
        DATA_EXFILTRATION,
        MALICIOUS_IP,
        SUSPICIOUS_DNS,
        TOR_USAGE,
        CRYPTO_MINING,
        PHISHING_DOMAIN
    }
    
    private val detectedThreats = mutableListOf<NetworkThreat>()
    
    init {
        loadMaliciousIndicators()
        startNetworkMonitoring()
    }
    
    /**
     * Load known malicious IPs and domains from threat intelligence feeds
     */
    private fun loadMaliciousIndicators() {
        // Known C2 servers and malicious IPs (sample - in production, load from API)
        maliciousIPs.addAll(listOf(
            "185.220.100.240", // Known Tor exit node
            "185.220.101.1",   // Malicious infrastructure
            "45.142.212.61",   // C2 server
            "91.219.236.197",  // Botnet C2
            "192.42.116.0",    // Tor network
        ))
        
        maliciousDomains.addAll(listOf(
            "*.onion",          // Tor hidden services
            "*.bit",            // Namecoin domains
            "cnc.example.com",  // C2 domains
            "bot.badactor.net",
            "malware-dist.xyz",
        ))
        
        // In production: Fetch from URLhaus, PhishTank, abuse.ch, etc.
        scope.launch {
            fetchThreatIntelFeeds()
        }
    }
    
    /**
     * Fetch real-time threat intelligence from external sources
     */
    private suspend fun fetchThreatIntelFeeds() {
        try {
            // URLhaus API - Known malicious URLs
            val urlhausData = fetchURLhaus()
            urlhausData?.let { parseURLhausData(it) }
            
            // PhishTank - Phishing domains
            // val phishTankData = fetchPhishTank()
            
        } catch (e: Exception) {
            android.util.Log.e("NetworkMonitor", "Failed to fetch threat intel: ${e.message}")
        }
    }
    
    private suspend fun fetchURLhaus(): String? = withContext(Dispatchers.IO) {
        try {
            val url = URL("https://urlhaus-api.abuse.ch/v1/urls/recent/")
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            connection.connectTimeout = 10000
            connection.readTimeout = 10000
            
            if (connection.responseCode == 200) {
                BufferedReader(InputStreamReader(connection.inputStream)).use { reader ->
                    reader.readText()
                }
            } else null
        } catch (e: Exception) {
            android.util.Log.e("NetworkMonitor", "URLhaus fetch failed: ${e.message}")
            null
        }
    }
    
    private fun parseURLhausData(jsonData: String) {
        try {
            val json = JSONObject(jsonData)
            val urls = json.getJSONArray("urls")
            
            for (i in 0 until urls.length().coerceAtMost(100)) {
                val urlObj = urls.getJSONObject(i)
                val domain = urlObj.optString("url_status")
                if (domain.isNotEmpty()) {
                    maliciousDomains.add(domain)
                }
            }
            android.util.Log.d("NetworkMonitor", "Loaded ${maliciousDomains.size} malicious domains")
        } catch (e: Exception) {
            android.util.Log.e("NetworkMonitor", "Failed to parse URLhaus data: ${e.message}")
        }
    }
    
    /**
     * Start monitoring network connections
     */
    private fun startNetworkMonitoring() {
        val networkRequest = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()
        
        val networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                super.onAvailable(network)
                android.util.Log.d("NetworkMonitor", "Network available: $network")
                analyzeNetworkTraffic(network)
            }
            
            override fun onCapabilitiesChanged(network: Network, networkCapabilities: NetworkCapabilities) {
                super.onCapabilitiesChanged(network, networkCapabilities)
                checkNetworkCapabilities(networkCapabilities)
            }
        }
        
        connectivityManager.registerNetworkCallback(networkRequest, networkCallback)
    }
    
    /**
     * Check network capabilities for suspicious configurations
     */
    private fun checkNetworkCapabilities(capabilities: NetworkCapabilities) {
        // Detect VPN usage (could indicate Tor or malicious proxy)
        if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_VPN)) {
            android.util.Log.w("NetworkMonitor", "VPN detected - potential Tor or proxy usage")
            // Check if it's a legitimate VPN or malicious
        }
    }
    
    /**
     * Analyze network traffic patterns
     */
    private fun analyzeNetworkTraffic(network: Network) {
        scope.launch {
            // Read /proc/net/tcp and /proc/net/udp for active connections
            val connections = parseNetworkConnections()
            
            connections.forEach { conn ->
                analyzeConnection(conn)
            }
        }
    }
    
    data class NetworkConnection(
        val localAddress: String,
        val localPort: Int,
        val remoteAddress: String,
        val remotePort: Int,
        val state: String,
        val uid: Int
    )
    
    /**
     * Parse /proc/net/tcp for active connections
     */
    private fun parseNetworkConnections(): List<NetworkConnection> {
        val connections = mutableListOf<NetworkConnection>()
        
        try {
            val process = Runtime.getRuntime().exec("cat /proc/net/tcp")
            BufferedReader(InputStreamReader(process.inputStream)).use { reader ->
                reader.readLine() // Skip header
                
                reader.forEachLine { line ->
                    val parts = line.trim().split(Regex("\\s+"))
                    if (parts.size >= 10) {
                        try {
                            val localAddr = parts[1].split(":")
                            val remoteAddr = parts[2].split(":")
                            
                            connections.add(NetworkConnection(
                                localAddress = hexToIP(localAddr[0]),
                                localPort = localAddr[1].toInt(16),
                                remoteAddress = hexToIP(remoteAddr[0]),
                                remotePort = remoteAddr[1].toInt(16),
                                state = parts[3],
                                uid = parts[7].toInt()
                            ))
                        } catch (e: Exception) {
                            // Skip malformed lines
                        }
                    }
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("NetworkMonitor", "Failed to parse network connections: ${e.message}")
        }
        
        return connections
    }
    
    /**
     * Convert hex IP to dotted decimal notation
     */
    private fun hexToIP(hex: String): String {
        if (hex.length != 8) return "0.0.0.0"
        
        return try {
            val ip = hex.toLong(16)
            "${(ip and 0xFF)}.${(ip shr 8 and 0xFF)}.${(ip shr 16 and 0xFF)}.${(ip shr 24 and 0xFF)}"
        } catch (e: Exception) {
            "0.0.0.0"
        }
    }
    
    /**
     * Analyze individual connection for threats
     */
    private fun analyzeConnection(conn: NetworkConnection) {
        val packageName = getPackageNameForUID(conn.uid) ?: "unknown"
        
        // Check against known malicious IPs
        if (maliciousIPs.contains(conn.remoteAddress)) {
            detectedThreats.add(NetworkThreat(
                packageName = packageName,
                type = ThreatType.MALICIOUS_IP,
                destination = conn.remoteAddress,
                description = "Connection to known malicious IP: ${conn.remoteAddress}",
                severity = "HIGH"
            ))
            android.util.Log.w("NetworkMonitor", "âš ï¸ THREAT: $packageName connecting to malicious IP: ${conn.remoteAddress}")
        }
        
        // Detect C2 patterns (non-standard ports, specific traffic patterns)
        if (isC2Pattern(conn)) {
            detectedThreats.add(NetworkThreat(
                packageName = packageName,
                type = ThreatType.C2_COMMUNICATION,
                destination = "${conn.remoteAddress}:${conn.remotePort}",
                description = "Suspected C2 communication on port ${conn.remotePort}",
                severity = "CRITICAL"
            ))
            android.util.Log.e("NetworkMonitor", "ðŸš¨ C2 DETECTED: $packageName â†’ ${conn.remoteAddress}:${conn.remotePort}")
        }
        
        // Detect data exfiltration (large uploads to external IPs)
        if (isDataExfiltration(conn, packageName)) {
            detectedThreats.add(NetworkThreat(
                packageName = packageName,
                type = ThreatType.DATA_EXFILTRATION,
                destination = conn.remoteAddress,
                description = "Abnormal data upload detected",
                severity = "HIGH"
            ))
        }
        
        // Update stats
        updateNetworkStats(packageName, conn)
    }
    
    /**
     * Detect C2 communication patterns
     */
    private fun isC2Pattern(conn: NetworkConnection): Boolean {
        // Common C2 ports
        val c2Ports = setOf(4444, 5555, 6666, 7777, 8080, 8888, 9999, 31337, 1337)
        
        if (c2Ports.contains(conn.remotePort)) {
            return true
        }
        
        // Check for connections to Tor network
        if (conn.remotePort in 9001..9051) {
            return true
        }
        
        // IRC-based C2 (ports 6667, 6697)
        if (conn.remotePort in listOf(6667, 6697)) {
            return true
        }
        
        return false
    }
    
    /**
     * Detect data exfiltration patterns
     */
    private fun isDataExfiltration(conn: NetworkConnection, packageName: String): Boolean {
        val stats = networkStats[packageName] ?: return false
        
        // Abnormally high connection count in short time
        if (stats.connectionCount > 100 && 
            System.currentTimeMillis() - stats.lastSeen < 60000) {
            return true
        }
        
        // Large data transfers (would need actual byte counting from /proc/net/dev)
        if (stats.bytesTransferred > 100_000_000) { // 100MB
            return true
        }
        
        return false
    }
    
    /**
     * Update network statistics for a package
     */
    private fun updateNetworkStats(packageName: String, conn: NetworkConnection) {
        val stats = networkStats.getOrPut(packageName) { NetworkActivity() }
        stats.connectionCount++
        stats.lastSeen = System.currentTimeMillis()
        
        if (maliciousIPs.contains(conn.remoteAddress)) {
            stats.suspiciousConnections++
        }
    }
    
    /**
     * Get package name for UID
     */
    private fun getPackageNameForUID(uid: Int): String? {
        return try {
            context.packageManager.getPackagesForUid(uid)?.firstOrNull()
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Get all detected network threats
     */
    fun getDetectedThreats(): List<NetworkThreat> = detectedThreats.toList()
    
    /**
     * Get network statistics for all apps
     */
    fun getNetworkStats(): Map<String, NetworkActivity> = networkStats.toMap()
    
    /**
     * Scan specific app for network threats
     */
    fun scanAppNetwork(packageName: String): List<NetworkThreat> {
        return detectedThreats.filter { it.packageName == packageName }
    }
    
    /**
     * Cleanup resources
     */
    fun cleanup() {
        scope.cancel()
    }
}
