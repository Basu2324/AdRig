package com.autoguard.malware_scanner

import android.app.ActivityManager
import android.content.Context
import android.os.Build
import android.os.Debug
import kotlinx.coroutines.*
import java.io.BufferedReader
import java.io.File
import java.io.InputStreamReader

/**
 * Real-time process behavior monitor for detecting:
 * - Abnormal CPU/memory usage
 * - Child process spawning (malware injection)
 * - Root/jailbreak detection evasion
 * - Debugger detection attempts
 * - Privilege escalation
 */
class ProcessMonitor(private val context: Context) {
    
    private val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    // Process behavior baselines
    private val processBaselines = mutableMapOf<String, ProcessBaseline>()
    private val detectedAnomalies = mutableListOf<ProcessAnomaly>()
    
    data class ProcessBaseline(
        var avgCpuUsage: Double = 0.0,
        var avgMemoryUsage: Long = 0,
        var childProcessCount: Int = 0,
        var suspiciousSystemCalls: Int = 0,
        var samples: Int = 0
    )
    
    data class ProcessAnomaly(
        val packageName: String,
        val pid: Int,
        val type: AnomalyType,
        val description: String,
        val severity: String,
        val timestamp: Long = System.currentTimeMillis()
    )
    
    enum class AnomalyType {
        CPU_SPIKE,
        MEMORY_LEAK,
        CHILD_PROCESS_SPAWN,
        ROOT_DETECTION,
        DEBUGGER_EVASION,
        PRIVILEGE_ESCALATION,
        SUSPICIOUS_SYSCALL,
        CODE_INJECTION
    }
    
    data class ProcessInfo(
        val pid: Int,
        val packageName: String,
        val cpuUsage: Double,
        val memoryUsage: Long,
        val threadCount: Int,
        val childProcesses: List<Int>
    )
    
    /**
     * Start continuous process monitoring
     */
    fun startMonitoring() {
        scope.launch {
            while (isActive) {
                try {
                    monitorRunningProcesses()
                    delay(5000) // Monitor every 5 seconds
                } catch (e: Exception) {
                    android.util.Log.e("ProcessMonitor", "Monitoring error: ${e.message}")
                }
            }
        }
    }
    
    /**
     * Monitor all running processes
     */
    private suspend fun monitorRunningProcesses() = withContext(Dispatchers.IO) {
        val runningProcesses = getRunningProcesses()
        
        runningProcesses.forEach { process ->
            analyzeProcess(process)
        }
        
        // Check for root/jailbreak
        checkDeviceSecurity()
    }
    
    /**
     * Get list of running processes
     */
    private fun getRunningProcesses(): List<ProcessInfo> {
        val processes = mutableListOf<ProcessInfo>()
        
        try {
            val runningApps = activityManager.runningAppProcesses ?: return processes
            
            runningApps.forEach { appProcess ->
                val packageName = appProcess.processName
                val pid = appProcess.pid
                
                val cpuUsage = getCPUUsage(pid)
                val memoryUsage = getMemoryUsage(pid)
                val threadCount = getThreadCount(pid)
                val childProcesses = getChildProcesses(pid)
                
                processes.add(ProcessInfo(
                    pid = pid,
                    packageName = packageName,
                    cpuUsage = cpuUsage,
                    memoryUsage = memoryUsage,
                    threadCount = threadCount,
                    childProcesses = childProcesses
                ))
            }
        } catch (e: Exception) {
            android.util.Log.e("ProcessMonitor", "Failed to get running processes: ${e.message}")
        }
        
        return processes
    }
    
    /**
     * Get CPU usage for a process
     */
    private fun getCPUUsage(pid: Int): Double {
        return try {
            val statFile = File("/proc/$pid/stat")
            if (!statFile.exists()) return 0.0
            
            val stats = statFile.readText().split(" ")
            if (stats.size < 15) return 0.0
            
            val utime = stats[13].toLongOrNull() ?: 0
            val stime = stats[14].toLongOrNull() ?: 0
            val totalTime = utime + stime
            
            // Convert to percentage (simplified)
            (totalTime / 100.0).coerceAtMost(100.0)
        } catch (e: Exception) {
            0.0
        }
    }
    
    /**
     * Get memory usage for a process
     */
    private fun getMemoryUsage(pid: Int): Long {
        return try {
            val memInfo = Debug.MemoryInfo()
            Debug.getMemoryInfo(memInfo)
            memInfo.totalPss.toLong() * 1024L // Convert to bytes
        } catch (e: Exception) {
            0L
        }
    }
    
    /**
     * Get thread count for a process
     */
    private fun getThreadCount(pid: Int): Int {
        return try {
            val taskDir = File("/proc/$pid/task")
            taskDir.listFiles()?.size ?: 0
        } catch (e: Exception) {
            0
        }
    }
    
    /**
     * Get child processes spawned by a process
     */
    private fun getChildProcesses(parentPid: Int): List<Int> {
        val children = mutableListOf<Int>()
        
        try {
            val process = Runtime.getRuntime().exec("ps -A")
            BufferedReader(InputStreamReader(process.inputStream)).use { reader ->
                reader.forEachLine { line ->
                    val parts = line.trim().split(Regex("\\s+"))
                    if (parts.size >= 3) {
                        val ppid = parts[2].toIntOrNull()
                        if (ppid == parentPid) {
                            parts[1].toIntOrNull()?.let { children.add(it) }
                        }
                    }
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("ProcessMonitor", "Failed to get child processes: ${e.message}")
        }
        
        return children
    }
    
    /**
     * Analyze a process for anomalous behavior
     */
    private fun analyzeProcess(process: ProcessInfo) {
        val baseline = processBaselines.getOrPut(process.packageName) { ProcessBaseline() }
        
        // Update baseline
        baseline.avgCpuUsage = ((baseline.avgCpuUsage * baseline.samples) + process.cpuUsage) / (baseline.samples + 1)
        baseline.avgMemoryUsage = ((baseline.avgMemoryUsage * baseline.samples) + process.memoryUsage) / (baseline.samples + 1)
        baseline.samples++
        
        // Detect CPU spike (3x average)
        if (process.cpuUsage > baseline.avgCpuUsage * 3 && baseline.samples > 10) {
            detectedAnomalies.add(ProcessAnomaly(
                packageName = process.packageName,
                pid = process.pid,
                type = AnomalyType.CPU_SPIKE,
                description = "CPU usage spike: ${process.cpuUsage}% (avg: ${baseline.avgCpuUsage.toInt()}%)",
                severity = "MEDIUM"
            ))
            android.util.Log.w("ProcessMonitor", "âš ï¸ CPU SPIKE: ${process.packageName} using ${process.cpuUsage}%")
        }
        
        // Detect memory leak (2x average)
        if (process.memoryUsage > baseline.avgMemoryUsage * 2 && baseline.samples > 10) {
            detectedAnomalies.add(ProcessAnomaly(
                packageName = process.packageName,
                pid = process.pid,
                type = AnomalyType.MEMORY_LEAK,
                description = "Memory usage spike: ${process.memoryUsage / 1024 / 1024}MB",
                severity = "MEDIUM"
            ))
        }
        
        // Detect child process spawning (malware injection technique)
        if (process.childProcesses.isNotEmpty()) {
            detectedAnomalies.add(ProcessAnomaly(
                packageName = process.packageName,
                pid = process.pid,
                type = AnomalyType.CHILD_PROCESS_SPAWN,
                description = "Spawned ${process.childProcesses.size} child process(es): ${process.childProcesses}",
                severity = "HIGH"
            ))
            android.util.Log.e("ProcessMonitor", "ðŸš¨ CHILD PROCESS: ${process.packageName} spawned ${process.childProcesses}")
        }
        
        // Detect excessive threads (possible code injection)
        if (process.threadCount > 50) {
            detectedAnomalies.add(ProcessAnomaly(
                packageName = process.packageName,
                pid = process.pid,
                type = AnomalyType.CODE_INJECTION,
                description = "Excessive threads: ${process.threadCount}",
                severity = "HIGH"
            ))
        }
        
        // Check for suspicious system calls
        checkSuspiciousSyscalls(process)
    }
    
    /**
     * Check for suspicious system calls indicating malicious activity
     */
    private fun checkSuspiciousSyscalls(process: ProcessInfo) {
        try {
            // Read syscall trace from /proc/[pid]/syscall
            val syscallFile = File("/proc/${process.pid}/syscall")
            if (!syscallFile.exists()) return
            
            val syscall = syscallFile.readText().trim()
            
            // Detect ptrace (used for anti-debugging and code injection)
            if (syscall.contains("ptrace")) {
                detectedAnomalies.add(ProcessAnomaly(
                    packageName = process.packageName,
                    pid = process.pid,
                    type = AnomalyType.DEBUGGER_EVASION,
                    description = "Detected ptrace syscall - possible anti-debugging",
                    severity = "HIGH"
                ))
                android.util.Log.e("ProcessMonitor", "ðŸš¨ PTRACE: ${process.packageName} using ptrace")
            }
            
            // Detect execve (could be launching malicious binaries)
            if (syscall.contains("execve")) {
                detectedAnomalies.add(ProcessAnomaly(
                    packageName = process.packageName,
                    pid = process.pid,
                    type = AnomalyType.PRIVILEGE_ESCALATION,
                    description = "Detected execve syscall - possible privilege escalation",
                    severity = "CRITICAL"
                ))
            }
        } catch (e: Exception) {
            // Permission denied or file not found - expected on some devices
        }
    }
    
    /**
     * Check device for root/jailbreak indicators
     */
    private fun checkDeviceSecurity() {
        // Check for common root binaries
        val rootPaths = listOf(
            "/system/app/Superuser.apk",
            "/sbin/su",
            "/system/bin/su",
            "/system/xbin/su",
            "/data/local/xbin/su",
            "/data/local/bin/su",
            "/system/sd/xbin/su",
            "/system/bin/failsafe/su",
            "/data/local/su",
            "/su/bin/su"
        )
        
        rootPaths.forEach { path ->
            if (File(path).exists()) {
                detectedAnomalies.add(ProcessAnomaly(
                    packageName = "system",
                    pid = 0,
                    type = AnomalyType.ROOT_DETECTION,
                    description = "Root binary detected: $path",
                    severity = "CRITICAL"
                ))
                android.util.Log.e("ProcessMonitor", "ðŸš¨ ROOT DETECTED: $path")
            }
        }
        
        // Check for root management apps
        val rootApps = listOf(
            "com.noshufou.android.su",
            "com.thirdparty.superuser",
            "eu.chainfire.supersu",
            "com.koushikdutta.superuser",
            "com.topjohnwu.magisk"
        )
        
        rootApps.forEach { packageName ->
            if (isPackageInstalled(packageName)) {
                detectedAnomalies.add(ProcessAnomaly(
                    packageName = packageName,
                    pid = 0,
                    type = AnomalyType.ROOT_DETECTION,
                    description = "Root management app detected: $packageName",
                    severity = "HIGH"
                ))
            }
        }
        
        // Check for test-keys (custom ROM indicator)
        if (Build.TAGS != null && Build.TAGS.contains("test-keys")) {
            detectedAnomalies.add(ProcessAnomaly(
                packageName = "system",
                pid = 0,
                type = AnomalyType.ROOT_DETECTION,
                description = "Device built with test-keys (custom ROM)",
                severity = "MEDIUM"
            ))
        }
    }
    
    /**
     * Check if package is installed
     */
    private fun isPackageInstalled(packageName: String): Boolean {
        return try {
            context.packageManager.getPackageInfo(packageName, 0)
            true
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Get all detected anomalies
     */
    fun getDetectedAnomalies(): List<ProcessAnomaly> = detectedAnomalies.toList()
    
    /**
     * Scan specific app for process anomalies
     */
    fun scanAppProcess(packageName: String): List<ProcessAnomaly> {
        return detectedAnomalies.filter { it.packageName == packageName }
    }
    
    /**
     * Get process baseline for an app
     */
    fun getProcessBaseline(packageName: String): ProcessBaseline? {
        return processBaselines[packageName]
    }
    
    /**
     * Cleanup resources
     */
    fun cleanup() {
        scope.cancel()
    }
}
