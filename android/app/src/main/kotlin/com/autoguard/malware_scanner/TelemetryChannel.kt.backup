package com.autoguard.malware_scanner

import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageInfo
import android.content.pm.ApplicationInfo
import android.os.Build
import io.flutter.plugin.common.MethodChannel
import java.io.File
import java.security.MessageDigest

class TelemetryChannel(private val context: Context) {
    
    companion object {
        const val CHANNEL_NAME = "com.adrig.security/telemetry"
    }
    
    fun setupMethodChannel(channel: MethodChannel) {
        channel.setMethodCallHandler { call, result ->
            when (call.method) {
                "getInstalledApps" -> {
                    try {
                        val apps = getInstalledApps()
                        result.success(apps)
                    } catch (e: Exception) {
                        result.error("GET_APPS_ERROR", e.message, null)
                    }
                }
                "getAppDetails" -> {
                    try {
                        val packageName = call.argument<String>("packageName")
                        if (packageName != null) {
                            val details = getAppDetails(packageName)
                            result.success(details)
                        } else {
                            result.error("INVALID_ARGUMENT", "Package name is required", null)
                        }
                    } catch (e: Exception) {
                        result.error("GET_APP_DETAILS_ERROR", e.message, null)
                    }
                }
                "scanFiles" -> {
                    try {
                        val path = call.argument<String>("path") ?: "/"
                        val files = scanFiles(path)
                        result.success(files)
                    } catch (e: Exception) {
                        result.error("SCAN_FILES_ERROR", e.message, null)
                    }
                }
                "getRunningProcesses" -> {
                    try {
                        val processes = getRunningProcesses()
                        result.success(processes)
                    } catch (e: Exception) {
                        result.error("GET_PROCESSES_ERROR", e.message, null)
                    }
                }
                "checkRootAccess" -> {
                    try {
                        val isRooted = checkRootAccess()
                        result.success(isRooted)
                    } catch (e: Exception) {
                        result.error("CHECK_ROOT_ERROR", e.message, null)
                    }
                }
                else -> result.notImplemented()
            }
        }
    }
    
    private fun getInstalledApps(): List<Map<String, Any?>> {
        val pm = context.packageManager
        val apps = mutableListOf<Map<String, Any?>>()
        
        val packages = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            pm.getInstalledPackages(PackageManager.GET_PERMISSIONS)
        }
        
        for (packageInfo in packages) {
            try {
                val appInfo = packageInfo.applicationInfo ?: continue
                val appData = mapOf(
                    "packageName" to packageInfo.packageName,
                    "appName" to pm.getApplicationLabel(appInfo).toString(),
                    "version" to packageInfo.versionName,
                    "versionCode" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                        packageInfo.longVersionCode
                    } else {
                        @Suppress("DEPRECATION")
                        packageInfo.versionCode.toLong()
                    },
                    "installer" to pm.getInstallerPackageName(packageInfo.packageName),
                    "installTime" to packageInfo.firstInstallTime,
                    "updateTime" to packageInfo.lastUpdateTime,
                    "isSystemApp" to ((appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0),
                    "apkPath" to (appInfo.sourceDir ?: ""),
                    "dataDir" to (appInfo.dataDir ?: ""),
                    "permissions" to (packageInfo.requestedPermissions?.toList() ?: emptyList())
                )
                apps.add(appData)
            } catch (e: Exception) {
                // Skip apps that can't be accessed
                continue
            }
        }
        
        return apps
    }
    
    private fun getAppDetails(packageName: String): Map<String, Any?> {
        val pm = context.packageManager
        
        val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            pm.getPackageInfo(packageName, PackageManager.PackageInfoFlags.of(
                (PackageManager.GET_PERMISSIONS or 
                 PackageManager.GET_ACTIVITIES or
                 PackageManager.GET_SERVICES or
                 PackageManager.GET_RECEIVERS or
                 PackageManager.GET_PROVIDERS).toLong()
            ))
        } else {
            @Suppress("DEPRECATION")
            pm.getPackageInfo(packageName, 
                PackageManager.GET_PERMISSIONS or 
                PackageManager.GET_ACTIVITIES or
                PackageManager.GET_SERVICES or
                PackageManager.GET_RECEIVERS or
                PackageManager.GET_PROVIDERS
            )
        }
        
        val appInfo = packageInfo.applicationInfo ?: return emptyMap()
        val apkFile = File(appInfo.sourceDir ?: return emptyMap())
        
        // Calculate APK hashes
        val hashes = calculateFileHashes(apkFile)
        
        // Get signing certificate
        val signingCert = getSigningCertificate(packageName)
        
        return mapOf(
            "packageName" to packageName,
            "appName" to pm.getApplicationLabel(appInfo).toString(),
            "version" to packageInfo.versionName,
            "versionCode" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                packageInfo.longVersionCode
            } else {
                @Suppress("DEPRECATION")
                packageInfo.versionCode.toLong()
            },
            "installer" to pm.getInstallerPackageName(packageName),
            "installTime" to packageInfo.firstInstallTime,
            "updateTime" to packageInfo.lastUpdateTime,
            "apkPath" to (appInfo.sourceDir ?: ""),
            "apkSize" to apkFile.length(),
            "dataDir" to (appInfo.dataDir ?: ""),
            "nativeLibraryDir" to (appInfo.nativeLibraryDir ?: ""),
            "isSystemApp" to ((appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0),
            "targetSdk" to appInfo.targetSdkVersion,
            "minSdk" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                appInfo.minSdkVersion
            } else {
                0
            },
            "permissions" to (packageInfo.requestedPermissions?.toList() ?: emptyList()),
            "activities" to (packageInfo.activities?.map { it.name } ?: emptyList()),
```
        } else {
            @Suppress("DEPRECATION")
            pm.getInstalledPackages(PackageManager.GET_PERMISSIONS)
        }
        
        for (packageInfo in packages) {
            try {
                val appInfo = packageInfo.applicationInfo
                val appData = mapOf(
                    "packageName" to packageInfo.packageName,
                    "appName" to pm.getApplicationLabel(appInfo).toString(),
                    "version" to packageInfo.versionName,
                    "versionCode" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                        packageInfo.longVersionCode
                    } else {
                        @Suppress("DEPRECATION")
                        packageInfo.versionCode.toLong()
                    },
                    "installer" to pm.getInstallerPackageName(packageInfo.packageName),
                    "installTime" to packageInfo.firstInstallTime,
                    "updateTime" to packageInfo.lastUpdateTime,
                    "isSystemApp" to ((appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0),
                    "apkPath" to appInfo.sourceDir,
                    "dataDir" to appInfo.dataDir,
                    "permissions" to (packageInfo.requestedPermissions?.toList() ?: emptyList())
                )
                apps.add(appData)
            } catch (e: Exception) {
                // Skip apps that can't be accessed
                continue
            }
        }
        
        return apps
    }
    
    private fun getAppDetails(packageName: String): Map<String, Any?> {
        val pm = context.packageManager
        
        val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            pm.getPackageInfo(packageName, PackageManager.PackageInfoFlags.of(
                (PackageManager.GET_PERMISSIONS or 
                 PackageManager.GET_ACTIVITIES or
                 PackageManager.GET_SERVICES or
                 PackageManager.GET_RECEIVERS or
                 PackageManager.GET_PROVIDERS).toLong()
            ))
        } else {
            @Suppress("DEPRECATION")
            pm.getPackageInfo(packageName, 
                PackageManager.GET_PERMISSIONS or 
                PackageManager.GET_ACTIVITIES or
                PackageManager.GET_SERVICES or
                PackageManager.GET_RECEIVERS or
                PackageManager.GET_PROVIDERS
            )
        }
        
        val appInfo = packageInfo.applicationInfo ?: return emptyMap()
        val apkFile = File(appInfo.sourceDir ?: return emptyMap())
        
        // Calculate APK hashes
        val hashes = calculateFileHashes(apkFile)
        
        // Get signing certificate
        val signingCert = getSigningCertificate(packageName)
        
        return mapOf(
            "packageName" to packageName,
            "appName" to pm.getApplicationLabel(appInfo).toString(),
            "version" to (packageInfo.versionName ?: ""),
            "versionCode" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                packageInfo.longVersionCode
            } else {
                @Suppress("DEPRECATION")
                packageInfo.versionCode.toLong()
            },
            "installer" to pm.getInstallerPackageName(packageName),
            "installTime" to packageInfo.firstInstallTime,
            "updateTime" to packageInfo.lastUpdateTime,
            "apkPath" to (appInfo.sourceDir ?: ""),
            "apkSize" to apkFile.length(),
            "dataDir" to (appInfo.dataDir ?: ""),
            "nativeLibraryDir" to (appInfo.nativeLibraryDir ?: ""),
            "isSystemApp" to ((appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0),
            "targetSdk" to appInfo.targetSdkVersion,
            "minSdk" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                appInfo.minSdkVersion
            } else {
                0
            },
            "permissions" to (packageInfo.requestedPermissions?.toList() ?: emptyList<String>()),
            "activities" to (packageInfo.activities?.map { it.name } ?: emptyList<String>()),
            "services" to (packageInfo.services?.map { it.name } ?: emptyList<String>()),
            "receivers" to (packageInfo.receivers?.map { it.name } ?: emptyList<String>()),
            "providers" to (packageInfo.providers?.map { it.name } ?: emptyList<String>()),
            "md5" to hashes["md5"],
            "sha1" to hashes["sha1"],
            "sha256" to hashes["sha256"],
            "signingCert" to signingCert
        )
    }
    
    private fun calculateFileHashes(file: File): Map<String, String> {
        val hashes = mutableMapOf<String, String>()
        
        try {
            val bytes = file.readBytes()
            
            // MD5
            val md5 = MessageDigest.getInstance("MD5")
            hashes["md5"] = md5.digest(bytes).toHexString()
            
            // SHA1
            val sha1 = MessageDigest.getInstance("SHA-1")
            hashes["sha1"] = sha1.digest(bytes).toHexString()
            
            // SHA256
            val sha256 = MessageDigest.getInstance("SHA-256")
            hashes["sha256"] = sha256.digest(bytes).toHexString()
        } catch (e: Exception) {
            hashes["md5"] = ""
            hashes["sha1"] = ""
            hashes["sha256"] = ""
        }
        
        return hashes
    }
    
    private fun getSigningCertificate(packageName: String): String {
        val pm = context.packageManager
        
        try {
            val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                pm.getPackageInfo(packageName, PackageManager.PackageInfoFlags.of(
                    PackageManager.GET_SIGNING_CERTIFICATES.toLong()
                ))
            } else {
                @Suppress("DEPRECATION")
                pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES)
            }
            
            val signatures = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                packageInfo.signingInfo?.apkContentsSigners
            } else {
                @Suppress("DEPRECATION")
                packageInfo.signatures
            }
            
            if (signatures != null && signatures.isNotEmpty()) {
                val cert = signatures[0].toByteArray()
                val sha256 = MessageDigest.getInstance("SHA-256")
                return sha256.digest(cert).toHexString()
            }
        } catch (e: Exception) {
            // Ignore
        }
        
        return ""
    }
    
    private fun scanFiles(rootPath: String): List<Map<String, Any?>> {
        val files = mutableListOf<Map<String, Any?>>()
        val root = File(rootPath)
        
        if (!root.exists() || !root.canRead()) {
            return files
        }
        
        try {
            root.walkTopDown()
                .maxDepth(5) // Limit recursion depth
                .take(1000)  // Limit number of files
                .forEach { file ->
                    try {
                        if (file.isFile) {
                            files.add(mapOf(
                                "path" to file.absolutePath,
                                "name" to file.name,
                                "size" to file.length(),
                                "lastModified" to file.lastModified(),
                                "canRead" to file.canRead(),
                                "canWrite" to file.canWrite(),
                                "canExecute" to file.canExecute(),
                                "isHidden" to file.isHidden
                            ))
                        }
                    } catch (e: Exception) {
                        // Skip files that can't be accessed
                    }
                }
        } catch (e: Exception) {
            // Handle security exceptions
        }
        
        return files
    }
    
    private fun getRunningProcesses(): List<Map<String, Any?>> {
        val processes = mutableListOf<Map<String, Any?>>()
        
        try {
            // Read /proc directory
            val procDir = File("/proc")
            if (procDir.exists() && procDir.canRead()) {
                procDir.listFiles()?.forEach { file ->
                    try {
                        val pid = file.name.toIntOrNull()
                        if (pid != null) {
                            val cmdline = File(file, "cmdline")
                            if (cmdline.exists() && cmdline.canRead()) {
                                val processName = cmdline.readText()
                                    .replace("\u0000", "")
                                    .trim()
                                
                                if (processName.isNotEmpty()) {
                                    processes.add(mapOf(
                                        "pid" to pid,
                                        "name" to processName
                                    ))
                                }
                            }
                        }
                    } catch (e: Exception) {
                        // Skip processes we can't read
                    }
                }
            }
        } catch (e: Exception) {
            // Handle security exceptions
        }
        
        return processes
    }
    
    private fun checkRootAccess(): Map<String, Any> {
        val indicators = mutableListOf<Map<String, Any>>()
        
        // Check for su binary
        val suPaths = listOf(
            "/system/bin/su",
            "/system/xbin/su",
            "/sbin/su",
            "/data/local/xbin/su",
            "/data/local/bin/su"
        )
        
        for (path in suPaths) {
            val file = File(path)
            if (file.exists()) {
                indicators.add(mapOf(
                    "type" to "SU_BINARY",
                    "path" to path,
                    "description" to "SuperUser binary found"
                ))
            }
        }
        
        // Check for root apps
        val rootApps = listOf(
            "com.topjohnwu.magisk",
            "eu.chainfire.supersu",
            "com.noshufou.android.su"
        )
        
        val pm = context.packageManager
        for (pkg in rootApps) {
            try {
                pm.getPackageInfo(pkg, 0)
                indicators.add(mapOf(
                    "type" to "ROOT_APP",
                    "path" to pkg,
                    "description" to "Root management app installed"
                ))
            } catch (e: Exception) {
                // App not installed
            }
        }
        
        // Check build properties
        val buildTags = Build.TAGS
        if (buildTags != null && buildTags.contains("test-keys")) {
            indicators.add(mapOf(
                "type" to "BUILD_TAGS",
                "path" to "Build.TAGS",
                "description" to "Device built with test-keys"
            ))
        }
        
        return mapOf(
            "isRooted" to (indicators.isNotEmpty()),
            "indicators" to indicators
        )
    }
    
    private fun ByteArray.toHexString(): String {
        return joinToString("") { "%02x".format(it) }
    }
}
